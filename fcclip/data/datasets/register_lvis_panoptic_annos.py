"""
This file may have been modified by Bytedance Ltd. and/or its affiliates (“Bytedance's Modifications”).
All Bytedance's Modifications are Copyright (year) Bytedance Ltd. and/or its affiliates.

This script registers the LVIS (Large Vocabulary Instance Segmentation) dataset
for panoptic segmentation tasks in Detectron2. It handles the loading of
annotations and the creation of metadata required for training and evaluation.

Reference: https://github.com/facebookresearch/Mask2Former/blob/main/mask2former/data/datasets/register_coco_panoptic_annos_semseg.py
"""

import json
import os

from detectron2.data import DatasetCatalog, MetadataCatalog
from . import openseg_classes

from detectron2.utils.file_io import PathManager


LVIS_CATEGORIES = openseg_classes.get_lvis_categories_with_prompt_eng()

_PREDEFINED_SPLITS_LVIS_PANOPTIC = {
    "openvocab_lvis_v1_train_panoptic": "coco/annotations/lvis_v1_train.json",
    "openvocab_lvis_v1_val_panoptic": "coco/annotations/lvis_v1_val.json",
}

def get_metadata():
    """
    Generates metadata for the LVIS panoptic dataset.

    The metadata includes mappings from category IDs to contiguous IDs for both
    'thing' and 'stuff' classes, class names, and colors, which are essential
    for training and visualization within Detectron2.

    Returns:
        dict: A dictionary containing the metadata.
    """
    meta = {}
    # The following metadata maps contiguous id from [0, #thing categories +
    # #stuff categories) to their names and colors. We have to replica of the
    # same name and color under "thing_*" and "stuff_*" because the current
    # visualization function in D2 handles thing and class classes differently
    # due to some heuristic used in Panoptic FPN. We keep the same naming to
    # enable reusing existing visualization functions.
    thing_classes = [k["name"] for k in LVIS_CATEGORIES if k["isthing"] == 1]
    thing_colors = [k["color"] for k in LVIS_CATEGORIES if k["isthing"] == 1]
    stuff_classes = [k["name"] for k in LVIS_CATEGORIES]
    stuff_colors = [k["color"] for k in LVIS_CATEGORIES]

    meta["thing_classes"] = thing_classes
    meta["thing_colors"] = thing_colors
    meta["stuff_classes"] = stuff_classes
    meta["stuff_colors"] = stuff_colors

    # Convert category id for training:
    #   category id: like semantic segmentation, it is the class id for each
    #   pixel. Since there are some classes not used in evaluation, the category
    #   id is not always contiguous and thus we have two set of category ids:
    #       - original category id: category id in the original dataset, mainly
    #           used for evaluation.
    #       - contiguous category id: [0, #classes), in order to train the linear
    #           softmax classifier.
    thing_dataset_id_to_contiguous_id = {}
    stuff_dataset_id_to_contiguous_id = {}
    contiguous_id_to_class_name = []

    for i, cat in enumerate(LVIS_CATEGORIES):
        if cat["isthing"]:
            thing_dataset_id_to_contiguous_id[cat["id"]] = i
        # else:
        #     stuff_dataset_id_to_contiguous_id[cat["id"]] = i

        # in order to use sem_seg evaluator
        stuff_dataset_id_to_contiguous_id[cat["id"]] = i

        contiguous_id_to_class_name.append(cat["name"])

    meta["thing_dataset_id_to_contiguous_id"] = thing_dataset_id_to_contiguous_id
    meta["stuff_dataset_id_to_contiguous_id"] = stuff_dataset_id_to_contiguous_id
    meta["contiguous_id_to_class_name"] = contiguous_id_to_class_name

    return meta


def load_lvis_panoptic_json(json_file, image_dir, meta):
    """
    Loads LVIS panoptic segmentation annotations from a JSON file.

    This function parses the JSON file and converts the annotations into the
    standard Detectron2 dataset format. It also maps the original category IDs
    to contiguous IDs for training purposes.

    Args:
        json_file (str): Path to the LVIS panoptic annotation JSON file.
        image_dir (str): Path to the directory containing the images.
        meta (dict): The metadata dictionary generated by `get_metadata()`.

    Returns:
        list[dict]: A list of dictionaries, where each dictionary represents an
                    image and its annotations in the Detectron2 standard format.
    """

    def _convert_category_id(segment_info, meta):
        """
        Converts a single segment's category ID to a contiguous ID and
        determines if it is a 'thing' or 'stuff' class.
        """
        ann = {
            "id": segment_info["id"],
            "segmentation": segment_info["segmentation"],
            "bbox": segment_info["bbox"],
            "area": segment_info["area"],
            "category_id": segment_info["category_id"],
        }
        if segment_info["category_id"] in meta["thing_dataset_id_to_contiguous_id"]:
            ann["category_id"] = meta["thing_dataset_id_to_contiguous_id"][ann["category_id"]]
            ann["isthing"] = True
        else:
            ann["category_id"] = meta["stuff_dataset_id_to_contiguous_id"][ann["category_id"]]
            ann["isthing"] = False
        return ann

    with PathManager.open(json_file) as f:
        json_info = json.load(f)

    per_image_annotations = {}
    for ann in json_info["annotations"]:
        image_id = int(ann["image_id"])
        if image_id not in per_image_annotations:
            # As per LVIS v1, file names can be derived from coco_url or flickr_url.
            # We use the zero-padded image_id.
            image_file = os.path.join(image_dir, f"{image_id:012d}.jpg")
            per_image_annotations[image_id] = {
                "file_name": image_file,
                "image_id": image_id,
                "segments_info": [],
            }

        per_image_annotations[image_id]["segments_info"].append(_convert_category_id(ann, meta))

    ret = [ann for ann in per_image_annotations.values()]

    assert len(ret), f"No images found in {image_dir}!"
    assert PathManager.isfile(ret[0]["file_name"]), ret[0]["file_name"]
    return ret


def register_lvis_panoptic(
    name, metadata, image_root, panoptic_json, instances_json=None
):
    """
    Registers an LVIS panoptic segmentation dataset in Detectron2.

    This function registers a dataset to the `DatasetCatalog` and its
    corresponding metadata to the `MetadataCatalog`.

    Args:
        name (str): The name to identify the dataset (e.g., "openvocab_lvis_v1_train_panoptic").
        metadata (dict): The metadata dictionary for the dataset.
        image_root (str): The root directory containing the images.
        panoptic_json (str): The path to the panoptic annotation JSON file.
        instances_json (str, optional): The path to the instance annotation
            JSON file. Defaults to None.
    """
    panoptic_name = name
    DatasetCatalog.register(
        panoptic_name,
        lambda: load_lvis_panoptic_json(panoptic_json, image_root, metadata),
    )
    MetadataCatalog.get(panoptic_name).set(
        image_root=image_root,
        panoptic_json=panoptic_json,
        json_file=instances_json,
        evaluator_type="coco_panoptic_seg",
        ignore_label=2048,
        label_divisor=5000,
        **metadata,
    )


def register_all_lvis_panoptic_annos(root):
    """
    Registers all predefined LVIS panoptic dataset splits.

    This function iterates through the `_PREDEFINED_SPLITS_LVIS_PANOPTIC`
    dictionary and calls `register_lvis_panoptic` for each split.

    Args:
        root (str): The root directory of the datasets.
    """
    for (prefix, panoptic_json) in _PREDEFINED_SPLITS_LVIS_PANOPTIC.items():
        instances_meta = MetadataCatalog.get("coco_2017_train" if "train" in prefix else "coco_2017_val")
        image_root, instances_json = instances_meta.image_root, instances_meta.json_file

        register_lvis_panoptic(
            prefix,
            get_metadata(),
            image_root,
            os.path.join(root, panoptic_json),
            instances_json=instances_json,
        )


_root = os.getenv("DETECTRON2_DATASETS", "datasets")
register_all_lvis_panoptic_annos(_root)